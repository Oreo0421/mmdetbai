from typing import List, Optional

import torch
from mmengine.structures import InstanceData

from mmdet.registry import MODELS
from mmdet.structures import SampleList

# RTMDet base may live in different module paths depending on mmdet version
try:
    from mmdet.models.detectors.rtmdet import RTMDet
except Exception:
    from mmdet.models.detectors import RTMDet


@MODELS.register_module(force=True)
class RTMDetWithPose(RTMDet):
    """RTMDet detector with an extra pose_head.

    - train: override loss() to include pose_head.loss()
    - val/test: override predict() to return DetDataSample list with pred_instances
    """

    def __init__(self, *args, pose_head=None, **kwargs):
        super().__init__(*args, **kwargs)
        assert pose_head is not None, "pose_head must be provided in config"
        self.pose_head = MODELS.build(pose_head)

    def loss(self,
             batch_inputs: torch.Tensor,
             batch_data_samples: SampleList) -> dict:
        """Compute detection loss + pose loss."""
        # (A) detection loss (cls/bbox/etc) - keep original RTMDet behavior
        det_losses = super().loss(batch_inputs, batch_data_samples)

        # (B) pose loss needs features
        feats = self.extract_feat(batch_inputs)
        pose_losses = self.pose_head.loss(feats, batch_data_samples)

        # Merge pose loss into det_losses with a stable key name for logging
        # Your pose head returns: dict(loss_keypoint=...)
        if isinstance(pose_losses, dict):
            if 'loss_keypoint' in pose_losses:
                det_losses['loss_kpt'] = pose_losses['loss_keypoint']
            else:
                # fallback: prefix any pose losses
                for k, v in pose_losses.items():
                    if k.startswith('loss'):
                        det_losses[f'loss_pose_{k}'] = v
                    else:
                        det_losses[f'pose_{k}'] = v

        return det_losses

    @torch.no_grad()
    def predict(self,
                batch_inputs: torch.Tensor,
                batch_data_samples: Optional[SampleList] = None,
                rescale: bool = True) -> SampleList:
        # 1) Standard bbox prediction: returns List[DetDataSample]
        data_samples = super().predict(batch_inputs, batch_data_samples, rescale=rescale)

        # 2) Extract features once
        feats = self.extract_feat(batch_inputs)

        # 3) Collect bbox InstanceData from each sample
        bbox_instances: List[InstanceData] = []
        for ds in data_samples:
            if hasattr(ds, 'pred_instances') and ds.pred_instances is not None:
                bbox_instances.append(ds.pred_instances)
            else:
                bbox_instances.append(InstanceData())

        # 4) Run pose head (writes keypoints/keypoint_scores into InstanceData)
        self.pose_head.predict(feats, bbox_instances, rescale=rescale)

        # 5) Write back
        for ds, inst in zip(data_samples, bbox_instances):
            ds.pred_instances = inst

        return data_samples
