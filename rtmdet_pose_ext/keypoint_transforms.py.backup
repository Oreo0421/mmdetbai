# Copyright (c) OpenMMLab. All rights reserved.
from typing import Dict, Tuple
import numpy as np
import torch

from mmdet.registry import TRANSFORMS
from mmcv.transforms import BaseTransform


class GeneratePoseHeatmap(BaseTransform):
    """为 7 个关键点生成高斯热图
    
    专为热红外人体检测设计，固定 7 个关键点：
    head, shoulder, hand_right, hand_left, hips, foot_right, foot_left
    
    Args:
        heatmap_size (tuple): 输出热图大小 (H, W)
        sigma (float): 高斯核标准差
    """
    
    def __init__(
        self,
        heatmap_size: Tuple[int, int] = (48, 48),
        sigma: float = 2.0,
    ):
        super().__init__()
        self.heatmap_size = heatmap_size
        self.sigma = sigma
        self.num_keypoints = 7  # 固定为 7 个关键点
    
    def transform(self, results: Dict) -> Dict:
        """生成关键点热图"""
        
        # 从 ann_info 中提取关键点 (COCO 格式)
        if 'ann_info' in results:
            ann_info = results['ann_info']
            if 'keypoints' in ann_info and len(ann_info['keypoints']) > 0:
                # COCO 格式: [x1, y1, v1, x2, y2, v2, ...]
                keypoints_flat = ann_info['keypoints']
                keypoints = np.array(keypoints_flat).reshape(-1, 3)
                
                # 添加到 gt_instances
                if 'gt_instances' in results:
                    results['gt_instances'].keypoints = keypoints
        
        # 检查 gt_instances
        if 'gt_instances' not in results:
            return results
        
        gt_instances = results['gt_instances']
        
        if not hasattr(gt_instances, 'keypoints') or len(gt_instances.keypoints) == 0:
            return results
        
        # 获取图像尺寸
        img_h, img_w = results['img_shape'][:2]
        heatmap_h, heatmap_w = self.heatmap_size
        
        # 获取关键点（假设单人检测）
        keypoints = np.array(gt_instances.keypoints)
        
        if keypoints.ndim == 2:  # 单实例
            keypoints = keypoints[np.newaxis, ...]
        
        num_instances = keypoints.shape[0]
        
        # 为所有实例初始化热图
        all_heatmaps = []
        all_weights = []
        
        for inst_idx in range(num_instances):
            kpts = keypoints[inst_idx]  # (7, 3)
            
            # 为这个实例生成热图
            heatmaps = np.zeros((7, heatmap_h, heatmap_w), dtype=np.float32)
            weights = np.zeros(7, dtype=np.float32)
            
            for kpt_idx in range(7):  # 固定 7 个关键点
                x, y, v = kpts[kpt_idx]
                
                # 可见性: 0=未标注, 1=遮挡, 2=可见
                if v == 0:
                    weights[kpt_idx] = 0.0
                    continue
                elif v == 1:
                    weights[kpt_idx] = 0.5  # 遮挡 - 降低权重
                else:  # v == 2
                    weights[kpt_idx] = 1.0  # 可见 - 全权重
                
                # 缩放关键点到热图分辨率
                x_hm = x * heatmap_w / img_w
                y_hm = y * heatmap_h / img_h
                
                # 生成高斯热图
                heatmaps[kpt_idx] = self._generate_gaussian_heatmap(
                    heatmap_w, heatmap_h, x_hm, y_hm, self.sigma
                )
            
            all_heatmaps.append(heatmaps)
            all_weights.append(weights)
        
        # 堆叠热图（单人检测时直接使用第一个）
        heatmaps = all_heatmaps[0] if len(all_heatmaps) == 1 else np.stack(all_heatmaps).sum(axis=0)
        weights = all_weights[0] if len(all_weights) == 1 else np.stack(all_weights).max(axis=0)
        
        # 添加到 gt_instances
        gt_instances.keypoints_heatmap = torch.from_numpy(heatmaps).float()
        gt_instances.keypoint_weights = torch.from_numpy(weights).float()
        
        return results
    
    def _generate_gaussian_heatmap(
        self,
        width: int,
        height: int,
        center_x: float,
        center_y: float,
        sigma: float,
    ) -> np.ndarray:
        """生成 2D 高斯热图"""
        
        # 创建坐标网格
        x = np.arange(0, width, 1, dtype=np.float32)
        y = np.arange(0, height, 1, dtype=np.float32)
        y = y[:, np.newaxis]
        
        # 计算 2D 高斯
        heatmap = np.exp(
            -((x - center_x) ** 2 + (y - center_y) ** 2) / (2 * sigma ** 2)
        )
        
        return heatmap
    
    def __repr__(self) -> str:
        repr_str = self.__class__.__name__
        repr_str += f'(heatmap_size={self.heatmap_size}, '
        repr_str += f'sigma={self.sigma}, '
        repr_str += f'num_keypoints=7)'
        return repr_str
